---
title: Termsharkを使ったパケットによる3ウェイハンドシェイクの理解
date: 2024-04-14 14:32:47 +0900
aliases: 
tags:
  - ネットワーク
  - パケット
  - tshark
  - termshark
  - wireshark
image: /img/banner/termshark-banner.webp
authors: haril
---

![banner](./termshark-banner.webp)

## ネットワークパケットとは？

データをネットワーク経由で送信するにはどうすれば良いでしょうか？受信者と接続を確立し、一度にすべてのデータを送信するのが最も簡単な方法のように思えます。しかし、この方法は複数のリクエストを処理する際に非効率的です。なぜなら、1つの接続は1回のデータ転送しか維持できないからです。大きなデータ転送のために接続が長引くと、他のデータは待たなければなりません。

データ送信プロセスを効率的に処理するために、ネットワークはデータを複数の部分に分割し、受信側がそれらを再構成する必要があります。これらの分割されたデータ構造をパケットと呼びます。パケットには、受信側がデータを正しい順序で再構成できるようにするための追加情報が含まれています。

複数のパケットでデータを送信することで、パケットスイッチングを通じて多くのリクエストを効率的に処理できますが、データの損失や誤った順序での配信など、さまざまなエラーが発生する可能性もあります。こうした問題をどのようにデバッグすれば良いのでしょうか？🤔

<!-- truncate -->

## Wireshark？いいえ...！Termsharkの出番です！

ネットワーク操作はカーネルによって隠されることが多いため、パケット解析ツールは効果的なデバッグに不可欠です。もちろん、既に多くのツールが存在しており、Wiresharkがその代表例です。

しかし、この記事では、Wiresharkのようなグラフィカルユーザーインターフェースが使用できない環境でもパケットを解析する方法を探ります。そのために、WiresharkのTUIバージョンである`termshark`を利用します。`termshark`は使い方が簡単で、ネットワーク解析を容易に行えます。

## インストールと使用方法

今回はMacに焦点を当てているため、`brew`を使ってインストールを進めます。

```bash
brew install termshark
```

パケットを検査するには、パケットが通過するネットワークデバイスを指定する必要があります。現在のマシンに存在するネットワークデバイスを確認するには、`termshark`を使用します。

```bash
termshark -D
```

基本的なコマンド`ifconfig`を使用して確認することもできます。

```bash
ifconfig
```

テストではループバックインターフェース（localhost）を使用します。出力を確認すると、`lo0`という名前のループバックインターフェースが見つかります。次のコマンドでネットワークパケットをキャプチャします。

```bash
termshark -i lo0 -w test.pcap # パケットをキャプチャし、test.pcapというファイルに保存
```

Termsharkを実行すると、ネットワークパケットのキャプチャ状態になります。

うーん...ループバックインターフェースはlocalhostにネットワークリクエストを送信するため、ローカルで動作するアプリケーションが必要です。別のターミナルウィンドウを開き、Dockerを使用して簡単なサーバーアプリケーションを実行しましょう。

```bash
docker run -d -p 8080:8080 songkg7/rest-server
```

このサーバーは、`/ping`エンドポイントにGETリクエストを行うと、文字列「pong」を返します。メッセージは短いですが、パケット操作の簡単な検査には十分です。

次に、ループバックにリクエストを送信します。

:::info

`Httpie`がインストールされていない場合は、代わりに`curl`を使用するか、`brew install httpie`でインストールできます。

:::

```bash
http localhost:8080/ping
```

tsharkセッションでキャプチャを停止するには、`ctrl + c`を押します。`la`と入力すると、`test.pcap`ファイルが作成されたことを確認できます。

## パケット解析

パケットキャプチャプロセスが完了しました。キャプチャ中にどのようなリクエストが行われたかを見てみましょう！すべてを表示するのではなく、興味のあるリクエストのみを表示するためのフィルタリング条件を指定できます。

```bash
termshark -r test.pcap tcp.port==8080 # ポート8080で交換されたパケットを表示
```

Termsharkは基本的なキー操作を提供します：

- 矢印キーまたはhjkl：カーソルを移動
- `tab`：ウィンドウ間のフォーカスを切り替え
- `?`：ヘルプ
- `/`：フィルタリング、特定のパケットを表示するために`tcp.port==8080`などを使用
- `q`：終了

TermsharkはWiresharkと同じカラーパレットを共有しており、デフォルト設定でも直感的なビジュアライゼーションを提供します。色を変更したい場合はWiresharkの設定を調整できますが、この記事の焦点から少し外れるため、省略します。

パケットに戻ると、パケットダンプは豊富な情報を提供しますが、いくつかの重要な詳細に焦点を当てましょう。基本的なTCP操作の流れは以下の画像のように進行します。

![](https://i.imgur.com/qiDbLAK.png)

上部には、SYNからSYN, ACK、そしてACKに進行する3ウェイハンドシェイクプロセスが見られます。このプロセスが完了すると、接続はESTABLISHED状態に入り、接続が確立されたことを示します。

詳細に見ると、初期段階ではシーケンス番号が交換され、どれだけのデータが双方間で送信されたかが決定されます。

![](https://i.imgur.com/HUcOEVH.png)
_クライアント側のシーケンス番号がSYNリクエスト中にサーバーに渡される_

SYNリクエスト中、クライアント側はクライアントによって設定されたシーケンス番号（4175220519）をサーバーに伝え、その後、

![](https://i.imgur.com/ONbTNaM.png)

サーバーはシーケンス番号（1538881812）を返し、次に受信するシーケンス番号を要求します。Acknowledge Numberは次に受信するシーケンス番号を示します。サーバーの視点から見ると、クライアントから4175220519を受信したため、次に4175220520を要求します。

3ウェイハンドシェイクの最後のパケットであるACKを詳しく見ると、

![](https://i.imgur.com/6wew0fe.png)

シーケンス番号4175220520を送信し、サーバーで受信したシーケンス番号1538881812からの増分を要求します。結果として1538881812 + 1 = 1538881813となります。接続状態はCLIENT_ESTABLISHEDに移行しました。

:::info

シーケンス番号は0や1から始まらないように設定されており、通信中のパケットの干渉を防ぐためにランダムな番号が割り当てられます。

:::

## 結論

`termshark`を使用した簡単なパケット解析方法を探りました。この記事では、3ウェイハンドシェイクに焦点を当てて長さを管理しましたが、パケット解析は豊富な情報を提供します。これがネットワーク操作を掘り下げるきっかけとなることを願っています。

## 参考文献

- [Cloudflare - パケットとは](https://www.cloudflare.com/ko-kr/learning/network-layer/what-is-a-packet/)
- [WiresharkでのTCP会話の完全性の確認方法](https://www.chappell-university.com/post/how-to-wireshark-tcp-conversation-completeness)